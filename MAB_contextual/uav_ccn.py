# uav_ccn.py

import random
import math
import time
import numpy as np

class UAV:
    def __init__(self, uav_id, grid_size, uav_grid_size, aggregator, current_zipf):
        self.uav_id = uav_id
        self.grid_size = grid_size
        self.uav_grid_size = uav_grid_size
        self.content_categories = ['II', 'III', 'IV']  # Content categories generated by the vehicle
        self.content_size = {'I':10, 'II': 1, 'III': 0.01, 'IV': 2}  # sizes of content as per category I:HDF, II:images , III:Sensory data, IV: Videos
        self.cache_size= 50 #Mbytes /50MB/ 150MB/500MB
        self.coverage_area = self.calculate_coverage_area()
        self.transmission_rate= 50 #Mbps
        self.propagation_delay= 100 #ms
        self.content_cache = {} # Cache to store content received from satellites and other UAVs
        self.epsilon = 0.1  # Epsilon value for epsilon-greedy strategy
        # 1. Define the Action Space
        self.num_actions = 0  # Initialize the number of actions to zero
        # A list to keep track of the available content categories
        self.action_space = []
        self.generated_cache = {
            'II': [],
            'III': [],
            'IV': []  # Add more categories if needed
        }  # Cache to store content received from satellites and other UAVs
        # Initialize the request tracking data structure
        self.record = {}  # An empty dictionary to track content request an content
        #self.global_rrequest_tracking = {} #an empty dictionary to track request in whole simulation time
        self.num_context_parameters=3
        self.request_receive_count=0
        self.request_receive_from_other_source=0
        self.global_request_receive_count=0
        self.content_hit_from_source=0
        self.content_hit_from_indirect_source = 0
        # Class attribute to store the current slot's content requests
        self.current_slot = None
        self.current_slot_content_requests = []
        self.content_hit = 0
        self.optimal_content_hit=0
        self.content_hit_source_uav_1st_hop = 0
        self.content_hit_source_uav_2nd_hop = 0
        self.content_hit_source_sat_2nd_hop = 0
        self.content_hit_cache_1st_hop = 0
        self.content_hit_cache_2nd_hop =0
        self.avg_decision_latency =0
        self.decision_count=0
        self.aggregator = aggregator
        self.current_zipf = current_zipf

    def update_zipf(self, current_slot):
            """
            Updates Zipf value dynamically every 60 slots.
            """
            self.current_zipf = random.uniform(0.25, 2.0)  # Generate new Zipf value

            return self.current_zipf

    def cache_cleanup(self, current_time):
        for content_coord, coord_cache in self.content_cache.items():
            for content_category, content_list in coord_cache.items():
                # Filter out content that has expired
                updated_content_list = [content for content in content_list if
                                        current_time < content['generation_time'] + content['content_validity']]
                # Update the cache with the filtered content list
                self.content_cache[content_coord][content_category] = updated_content_list
        return

    def sigmoid(self, x):
        return 1 / (1 + math.exp(-x))


    def calculate_coverage_area(self):
        uav_index = int(self.uav_id[3:])
        x1 = (uav_index % (self.grid_size // self.uav_grid_size)) * self.uav_grid_size
        x2 = x1 + self.uav_grid_size
        y1 = (uav_index // (self.grid_size // self.uav_grid_size)) * self.uav_grid_size
        y2 = y1 + self.uav_grid_size
        coverage_area = (x1, y1), (x2, y2)
        #print(f"UAV {self.uav_id} coverage area: {coverage_area}")
        return coverage_area

    def add_neighbor(self, neighbor_uav):
        self.neighbors.append(neighbor_uav)


    def process_content_request(self, communication, requesting_vehicle, content_request, vehicles, uavs, satellites, slot, communication_schedule):

        #print(f"UAV {self.uav_id} received request: {content_request['coord']}, {content_request['category']}, {content_request['no']}")
        # Implement the logic to process the received content request
        requested_entity_type = content_request['type']
        requested_coord = content_request['coord']
        requested_category = content_request['category']
        requested_content_no= content_request['no']
        self.request_receive_count += 1
        self.global_request_receive_count +=1

        # optimal content hit computation
        # Update the request tracking data structure per slot
        if (slot > 10) and ((slot - 1) % 10) == 0:
            satellite_list = communication.get_connected_satellites(slot-1, communication_schedule, satellites)
            total_content_size = 0
            content_size=0
            for element in self.current_slot_content_requests:
                if element['type'] == "satellite":
                        for satellite in satellite_list:
                            if element['coord'] == satellite:
                                content_size = self.content_size.get(element['category'], 0)
                                self.optimal_content_hit += 1
                                break
                elif element['type'] == "UAV":
                                content_size = self.content_size.get(element['category'], 0)
                                self.optimal_content_hit += 1
                total_content_size += content_size
                if total_content_size >= self.cache_size:
                    break
            self.current_slot_content_requests = []
# Update the request tracking data structure for the current slot

        # Update the request tracking data structure
        if requested_entity_type not in self.record:
            self.record[requested_entity_type] = {}
        if requested_coord not in self.record[requested_entity_type]:
            self.record[requested_entity_type][requested_coord] = {}
        if requested_category not in self.record[requested_entity_type][requested_coord]:
            self.record[requested_entity_type][requested_coord][requested_category] = {}
        if requested_content_no not in self.record[requested_entity_type][requested_coord][requested_category]:
            self.record[requested_entity_type][requested_coord][requested_category][requested_content_no] = {
                                        'weighted_request_tracking': 0,
                                        'request_tracking': 0,
                                        'content_hit': 0,
                                        'q_value': 0,
                                        'avg_reward': 0,
                                        'no_f_time_cached':0,
                                        'slot':0
        }
        self.record[requested_entity_type][requested_coord][requested_category][requested_content_no]['request_tracking'] += 1

        #for neighbor in self.neighbors:
           #print(f"neighbor: {neighbor.uav_id}, {content_request['coord']}, {content_request['type']}")
    # Check if the requested content is in the generated_cache of the receiving UAV

        if requested_entity_type == "UAV":
            if content_request['coord'] == self.uav_id: # Check if the requested content is in the generated_cache of the receiving UAV
                # Content request is for content generated by this UAV
                if requested_category in self.generated_cache:
                    category_cache = self.generated_cache[requested_category]
                    for content in category_cache:
                        if content['content_no'] == content_request['no']:
                            communication.content_received_time = content_request['time_spent']+ ((content[
                                                                             'size'] * 8) / self.transmission_rate) + random.uniform(
                                0.007, 0.01)
                            #self.track_content_hit(content)

                            #communication.content_hit += 1
                            self.content_hit_source_uav_1st_hop +=1
                            requesting_vehicle.update_action_space(content, slot, federated_update=False)
                            return content
            else:
                flag=0
                for neighbor in self.neighbors:
                    #print(f"neighbour: {neighbor.uav_id}", content_request['coord'] )
                    if content_request['coord'] == neighbor.uav_id: # Content request is for content generated by a neighbor UAV
                        if requested_category in neighbor.generated_cache:
                            category_cache = neighbor.generated_cache[requested_category]
                            for content in category_cache:
                                if content['content_no'] == content_request['no']:
                                    #print(
                                        #f"UAV {self.uav_id} has satisfied the request by neighbor {neighbor.uav_id}'s generated content: {content_request['unique_id']}")
                                    communication.content_received_time = content_request['time_spent'] + 2 * ((content[
                                                                                     'size'] * 8) / self.transmission_rate) + 2 * random.uniform(
                                        0.007, 0.01)  # transmission rate by receving UAV + transmission rate by neighbour UAV  + 2 * processing delay
                                    # Store content_received_time in a text file
                                    #self.track_content_hit(content)
                                    #communication.content_hit += 1
                                    flag = 1
                                    self.content_hit_source_uav_2nd_hop += 1
                                    requesting_vehicle.update_action_space(content, slot, federated_update=False)

                                    return content
                if flag==0:
                        self.request_receive_from_other_source += 1 #content is for some other non -neighbour uav
                        '''self.current_slot_content_requests.append({ 
                            'type': requested_entity_type,
                            'coord': requested_coord,
                            'category': requested_category,
                            'content_no': requested_content_no,

                            # Add other relevant information from content_request
                        })
                        for uav in uavs:
                            if content_request['coord'] == uav.uav_id:
                                if requested_category in uav.generated_cache:
                                    category_cache = uav.generated_cache[requested_category]
                                    for content in category_cache:
                                        if content['content_no'] == content_request['no']:
                                            #communication.content_received_time = content_request['time_spent'] + 2 * ((content['size'] * 8) / self.transmission_rate) + 2 * random.uniform(
                                                #0.007, 0.01) + 4 * random.uniform(0.04,
                                                                                  #0.06) + 10 # transmission rate by receiving uav + non neighbour  uav + 4 propagation delay between uav and satellites
                                            return content'''


        if requested_entity_type == "UAV" or requested_entity_type == "satellite": #caching
            if requested_coord in self.content_cache: #receiving uav caching
                if requested_category in self.content_cache[requested_coord]:
                    category_cache = self.content_cache[requested_coord][requested_category]
                    for content in category_cache:
                        if content['content_no'] == content_request['no']:
                            #Content found in the generated_cache, send it to the requesting vehicle
                            if (communication.content_received_time > content_request['time_spent']+ ((content[
                                                                             'size'] * 8) / self.transmission_rate) + random.uniform(0.007, 0.01)):
                                    communication.content_received_time = content_request['time_spent']+ ((content[
                                                                             'size'] * 8) / self.transmission_rate) + random.uniform(0.007, 0.01)
                            self.track_content_hit(content, slot)
                            communication.content_hit += 1
                            self.content_hit_cache_1st_hop += 1
                            requesting_vehicle.update_action_space(content, slot, federated_update=False)
                            return content
                # Check if the requested content is in the general content cache of this UAV's neighbors
            elif any(requested_coord in neighbor.content_cache for neighbor in self.neighbors):
                    for neighbor in self.neighbors: #neighbour cache
                        if requested_coord in neighbor.content_cache:
                            if requested_category in neighbor.content_cache[requested_coord]:
                                 category_cache = neighbor.content_cache[requested_coord][requested_category]
                                 for content in category_cache:
                                    if content['content_no'] == content_request['no']:
                                        #print(\
                                       # f"UAV {self.uav_id} has satisfied the request by neighbor {neighbor.uav_id}'s cached content: {content_request['unique_id']}")
                                        if (communication.content_received_time > content_request['time_spent'] + 2 * ((content[
                                                                                     'size'] * 8) / self.transmission_rate) + 2 * random.uniform(
                                        0.007, 0.01)) :
                                            communication.content_received_time = content_request['time_spent'] + 2 * ((content[
                                                                                     'size'] * 8) / self.transmission_rate) + 2 * random.uniform(
                                        0.007, 0.01)
                                        self.track_content_hit(content, slot)
                                        communication.content_hit += 1
                                        self.content_hit_cache_2nd_hop += 1
                                        requesting_vehicle.update_action_space(content, slot, federated_update=False)
                                        return content

        if requested_entity_type == "satellite":
                #connected_satellites=self.get_connected_satellites(communication_schedule, slot)
                connected_satellites = communication.get_connected_satellites(slot, communication_schedule, satellites)
                flag=0
                for satellite in connected_satellites:
                    if satellite.satellite_id ==content_request['coord']:
                        if requested_category in satellite.generated_cache:
                            category_cache = satellite.generated_cache[requested_category]
                            for content in category_cache:
                                if content['content_no'] == content_request['no']:
                                    #print(
                                       # f"UAV {self.uav_id} has satisfied the request by satellite {satellite.satellite_id}'s generated content: {content_request['unique_id']}")
                                    communication.content_received_time = content_request['time_spent'] + ((content['size'] * 8) / satellite.transmission_rate) +  random.uniform(
                                        0.007, 0.01) + 2 * random.uniform(0.04, 0.06)
                                    #
                                    #communication.content_hit += 1
                                    self.content_hit_source_sat_2nd_hop += 1
                                    requesting_vehicle.update_action_space(content, slot, federated_update=False)
                                    flag = 1
                                    return content
                if flag==0:
                        self.request_receive_from_other_source += 1
                        self.current_slot_content_requests.append({
                            'type': requested_entity_type,
                            'coord': requested_coord,
                            'category': requested_category,
                            'content_no': requested_content_no,

                            # Add other relevant information from content_request
                        })
                        flag1=0
                        for uav in uavs:
                            if requested_coord in uav.content_cache:  # receiving uav caching
                                if requested_category in uav.content_cache[requested_coord]:
                                    category_cache = uav.content_cache[requested_coord][requested_category]
                                    for content in category_cache:
                                        if content['content_no'] == content_request['no']:
                                                #communication.content_received_time = content_request['time_spent'] + 2 * ((content[
                                                                                                                  #  'size'] * 8) / self.transmission_rate) + 2 * random.uniform(0.007, 0.01) + 4 * random.uniform(0.04, 0.06) +10
                                                flag1 = 1
                                                return content

                        #if flag1 == 0:
                            #communication.content_received_time = content_request['time_spent'] + 100
                            #return None


        return 0


    def track_content_hit(self, content, slot):
        #print('track_content_hit')
        content_type = content['content_type']
        content_coord = content['content_coord']
        content_category = content['content_category']
        content_no = content['content_no']

        if content_type not in self.record:
            self.record[content_type] = {}

        if content_coord not in self.record[content_type]:
            self.record[content_type][content_coord] = {}

        if content_category not in self.record[content_type][content_coord]:
            self.record[content_type][content_coord][content_category] = {}

        if content_no not in self.record[content_type][content_coord][content_category]:
            self.record[content_type][content_coord][content_category][content_no] = {
                    'weighted_request_tracking': 0,
                    'request_tracking': 0,
                    'content_hit': 0,
                    'q_value': 0,
                    'avg_reward': 0,
                    'no_f_time_cached':0,
                    'slot':0
            }

        # Update the content hit information
        self.record[content_type][content_coord][content_category][content_no]['content_hit'] += 1
        self.record[content_type][content_coord][content_category][content_no]['slot'] = slot
        #print(f"track_content_hit: {self.record[content_type][content_coord][content_category][content_no]['content_hit']}")
        return


        # If the content is not found in any of these caches, you can add additional actions or error handling as needed.


    def generate_content(self, slot, current_time, no_of_content_each_category):
        content_validity = 15 * 60  # 15 minutes in seconds
        # Generate content for connected satellites

        if(slot==1):
            for category in self.content_categories:
                category_contents = []
                content_size = self.content_size.get(category, 0)
                num_contents = no_of_content_each_category  # Adjust the range as needed
                for n in range(1, num_contents+1):
                    content = {
                        'content_type': UAV,
                        'content_category': category,
                        'content_coord': self.uav_id,
                        'size': content_size,
                        'content_no': n,
                        'destination': None,
                        'generation_time': current_time,
                        'hop_count': 0,
                        'generation_time': current_time,
                        'content_validity': content_validity,
                        'content_hit': 0,

                    }
                    category_contents.append(content)
                self.generated_cache[category] = category_contents
        else:
                for category, contents in self.generated_cache.items():
                    for content in contents:
                        content['generation_time'] = current_time

            # Add the generated content to the GroundStation's content_cache for this category


    def print_cache(self):
        print("Generated Cache for uav", self.uav_id)
        for category, contents in self.generated_cache.items():
            print(f"Category: {category}", end=' ')
            for content in contents:
                print(f"Content Number: {content['content_no']}", end=' ')
            print()  # Print a new line after each category

    def cache_content(self, communication, communication_schedule, slot, uavs, satellites):
        target_slot=1
        if slot>10:
            target_slot=slot-1
        # Determine connected satellites and non-neighbor UAVs
        satellite_list = []
        non_neighbor_uavs = []
        satellite_list = communication.get_connected_satellites(target_slot, communication_schedule, satellites)
        non_neighbor_uavs = [uav for uav in uavs if
                             uav.uav_id != self.uav_id and uav.uav_id not in [neighbor.uav_id for neighbor in self.neighbors]]
        '''# Print the connected satellites
        print('Connected Satellites:')
        for satellite in satellite_list:
            print(satellite.satellite_id)

        # Print the non-neighbor UAVs
        print('Non-Neighbor UAVs:')
        for uav in non_neighbor_uavs:
            print(uav.uav_id)'''

        # Update the action space based on connected satellites
        self.update_action_space(satellite_list, non_neighbor_uavs, slot, federated_update=False)

        # Select an action (which content to cache) based on the learned policy
        self.select_action()
        # Print the content_cache
         # Print each element of content_cache
        #print("Content Cache after selecting actions:")

        '''if(slot == 10):
            for s_coord, coord_data in self.content_cache.items():
                for s_category, category_data in coord_data.items():
                    for content in category_data:
                        print(f"{self.uav_id} --Coord: {s_coord}, Category: {s_category}, Content: {content}")'''



    def update_action_space(self, satellite_list, non_neighbor_uavs, slot, federated_update): #ucb MAB
        #print('update_action_space')
        # Clear the existing action space
        self.action_space = []

        # For each connected satellite, add its generated content to the action space
        for satellite in satellite_list:
            for category, content_list in satellite.generated_cache.items():
                for content in content_list:
                    # Initialize the Q-value for the content to 0
                    # Add content and its associated Q-value
                    if content['content_type'] not in self.record:
                        self.record[content['content_type']]={}
                    if content['content_coord'] not in self.record[content['content_type']]:
                        self.record[content['content_type']][content['content_coord']]={}
                    if content['content_category'] not in self.record[content['content_type']][content['content_coord']]:
                        self.record[content['content_type']][content['content_coord']][content['content_category']]={}
                    if content['content_no'] not in self.record[content['content_type']][content['content_coord']][content['content_category']]:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']]= {
                                        'weighted_request_tracking': 0,
                                        'request_tracking': 0,
                                        'content_hit': 0,
                                        'q_value': 0,
                                        'avg_reward': 0,
                                        'no_f_time_cached':0,
                                        'slot': 0
                                    }
                    time_spent=(slot*60) - content['generation_time']
                    if self.request_receive_count > 0:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']]\
                            ['weighted_request_tracking'] \
                            = self.sigmoid((0.25 *
                               self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']]  \
                                   ['weighted_request_tracking']) + 0.75 * (
                              self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']][
                                  'request_tracking']/self.request_receive_count))

                    p = self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']] \
                        ['weighted_request_tracking']
                    s = max(1, self.record[content['content_type']][content['content_coord']]
                    [content['content_category']][content['content_no']]['slot'])  # Ensure s >= 1

                    no_f_time_cached = max(1, self.record[content['content_type']][content['content_coord']]
                    [content['content_category']][content['content_no']]['no_f_time_cached'])  # Ensure >=1

                    ucb = np.sqrt((2 * np.log(s)) / no_f_time_cached)  # Now always valid

                    local_q_value = self.sigmoid(self.record[content['content_type']][content['content_coord']]
                                     [content['content_category']][content['content_no']]['avg_reward'] +
                                     (self.cache_size / content['size']) +
                                     ((content['content_validity'] - time_spent) / content['content_validity']) +
                                     self.record[content['content_type']][content['content_coord']]
                                     [content['content_category']][content['content_no']][
                                         'weighted_request_tracking']) 
                    if federated_update:
                        federated_q_value = self.aggregator.get_federated_q_value(content)
                        q = 0.5 * local_q_value + 0.5 * federated_q_value + ucb  # Weighted Combination
                    else:
                        q = local_q_value + ucb

                    self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']]['q_value'] = q

                    # Add content and associated Q-value to the action space
                    self.action_space.append(
                        {'content': content, 'q_value': q,  'slot': s, 'popularity': p})
        # For each non-neighbor UAV, add its generated content to the action space
        for uav in non_neighbor_uavs:
            for category, content_list in uav.generated_cache.items():
                for content in content_list:
                    # Initialize the Q-value for the content to 0
                    if content['content_type'] not in self.record:
                        self.record[content['content_type']] = {}
                    if content['content_coord'] not in self.record[content['content_type']]:
                        self.record[content['content_type']][content['content_coord']] = {}
                    if content['content_category'] not in self.record[content['content_type']][
                        content['content_coord']]:
                        self.record[content['content_type']][content['content_coord']][content['content_category']] = {}
                    if content['content_no'] not in self.record[content['content_type']][content['content_coord']][\
                        content['content_category']]:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][\
                            content['content_no']] = {
                            'weighted_request_tracking': 0,
                            'request_tracking': 0,
                            'content_hit': 0,
                            'q_value': 0,
                            'avg_reward': 0,
                            'no_f_time_cached': 0,
                            'slot':0
                        }
                    time_spent = (slot * 60) - content['generation_time']
                    if self.request_receive_count > 0:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][
                            content['content_no']] \
                            ['weighted_request_tracking'] \
                            = self.sigmoid((0.25 *
                                            self.record[content['content_type']][content['content_coord']][
                                                content['content_category']][content['content_no']] \
                                                ['weighted_request_tracking']) + 0.75 * (
                                                   self.record[content['content_type']][content['content_coord']][
                                                       content['content_category']][content['content_no']][
                                                       'request_tracking'] / self.request_receive_count))

                    p = self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']] \
                        ['weighted_request_tracking']

                    s = max(1, self.record[content['content_type']][content['content_coord']]
                    [content['content_category']][content['content_no']]['slot'])  # Ensure s >= 1

                    no_f_time_cached = max(1, self.record[content['content_type']][content['content_coord']]
                    [content['content_category']][content['content_no']]['no_f_time_cached'])  # Ensure >=1

                    ucb = np.sqrt((2 * np.log(s)) / no_f_time_cached)  # Now always valid

                    local_q_value = self.sigmoid(self.record[content['content_type']][content['content_coord']]
                                     [content['content_category']][content['content_no']]['avg_reward'] +
                                     (self.cache_size / content['size']) +
                                     ((content['content_validity'] - time_spent) / content['content_validity']) +
                                     self.record[content['content_type']][content['content_coord']]
                                     [content['content_category']][content['content_no']][
                                         'weighted_request_tracking']) 
                    if federated_update:
                        federated_q_value = self.aggregator.get_federated_q_value(content)
                        q = 0.5 * local_q_value + 0.5 * federated_q_value + ucb  # Weighted Combination
                    else:
                        q = local_q_value + ucb

                    self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']]['q_value'] = q

                    # Add content and associated Q-value to the action space
                    self.action_space.append(
                        {'content': content, 'q_value': q,  'slot': s, 'popularity': p})

        # Add content from content_cache to the action space
        for coord, coord_data in self.content_cache.items():
                for category, category_data in coord_data.items():
                    for content in category_data:
                    # Initialize the Q-value for the content to 0
                        if content['content_type'] not in self.record:
                            self.record[content['content_type']] = {}
                        if content['content_coord'] not in self.record[content['content_type']]:
                            self.record[content['content_type']][content['content_coord']] = {}
                        if content['content_category'] not in self.record[content['content_type']][
                            content['content_coord']]:
                            self.record[content['content_type']][content['content_coord']][
                                content['content_category']] = {}
                        if content['content_no'] not in self.record[content['content_type']][content['content_coord']][ \
                                content['content_category']]:
                            self.record[content['content_type']][content['content_coord']][content['content_category']][ \
                                content['content_no']] = {
                                'weighted_request_tracking': 0,
                                'request_tracking': 0,
                                'content_hit': 0,
                                'q_value': 0,
                                'avg_reward': 0,
                                'no_f_time_cached': 0,
                                'slot':0
                            }
                        time_spent = (slot * 60) - content['generation_time']
                    if self.request_receive_count > 0:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][
                            content['content_no']] \
                            ['weighted_request_tracking'] \
                            = self.sigmoid((0.25 *
                                            self.record[content['content_type']][content['content_coord']][
                                                content['content_category']][content['content_no']] \
                                                ['weighted_request_tracking']) + 0.75 * (
                                                   self.record[content['content_type']][content['content_coord']][
                                                       content['content_category']][content['content_no']][
                                                       'request_tracking'] / self.request_receive_count))

                    p = self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']] \
                        ['weighted_request_tracking']
                    s = max(1, self.record[content['content_type']][content['content_coord']]
                    [content['content_category']][content['content_no']]['slot'])  # Ensure s >= 1

                    no_f_time_cached = max(1, self.record[content['content_type']][content['content_coord']]
                    [content['content_category']][content['content_no']]['no_f_time_cached'])  # Ensure >=1

                    ucb = np.sqrt((2 * np.log(s)) / no_f_time_cached)  # Now always valid

                    local_q_value = self.sigmoid(self.record[content['content_type']][content['content_coord']]
                                     [content['content_category']][content['content_no']]['avg_reward'] +
                                     (self.cache_size / content['size']) +
                                     ((content['content_validity'] - time_spent) / content['content_validity']) +
                                     self.record[content['content_type']][content['content_coord']]
                                     [content['content_category']][content['content_no']][
                                         'weighted_request_tracking']) 
                    if federated_update:
                        federated_q_value = self.aggregator.get_federated_q_value(content)
                        q = 0.5 * local_q_value + 0.5 * federated_q_value + ucb  # Weighted Combination
                    else:
                        q = local_q_value + ucb

                    self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']]['q_value'] = q

                    # Add content and associated Q-value to the action space
                    self.action_space.append(
                        {'content': content, 'q_value': q,  'slot': s, 'popularity': p})

        #print(f"Action Space: { self.uav_id, len(self.action_space)}")
        # Print the total action space at the end of both loops
        '''for action in self.action_space:
            print(f'Content: {action["content"]}, Q-value: {action["q_value"]}, ucb: {ucb},  slot: {s}')'''

    '''def update_action_space(self, satellite_list, non_neighbor_uavs, slot, federated_update=False ): #for MAB and all
        #print('update_action_space')
        # Clear the existing action space
        self.action_space = []

        # For each connected satellite, add its generated content to the action space
        for satellite in satellite_list:
            for category, content_list in satellite.generated_cache.items():
                for content in content_list:
                    # Initialize the Q-value for the content to 0
                    # Add content and its associated Q-value
                    if content['content_type'] not in self.record:
                        self.record[content['content_type']]={}
                    if content['content_coord'] not in self.record[content['content_type']]:
                        self.record[content['content_type']][content['content_coord']]={}
                    if content['content_category'] not in self.record[content['content_type']][content['content_coord']]:
                        self.record[content['content_type']][content['content_coord']][content['content_category']]={}
                    if content['content_no'] not in self.record[content['content_type']][content['content_coord']][content['content_category']]:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']]= {
                                        'weighted_request_tracking': 0,
                                        'request_tracking': 0,
                                        'content_hit': 0,
                                        'q_value': 0,
                                        'avg_reward': 0,
                                        'no_f_time_cached':0,
                                        'slot': 0
                                    }
                    time_spent=(slot*60) - content['generation_time']
                    if self.request_receive_count > 0:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']]\
                            ['weighted_request_tracking'] \
                            = self.sigmoid((0.25 *
                               self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']]  \
                                   ['weighted_request_tracking']) + 0.75 * (
                              self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']][
                                  'request_tracking']/self.request_receive_count))

                    p = self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']] \
                        ['weighted_request_tracking']
                    s = self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']]['slot']

                    q= self.sigmoid(self.record[content['content_type']][content['content_coord']][
                                         content['content_category']] \
                                         [content['content_no']]['avg_reward'])


                    self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']]['q_value'] = q

                    # Add content and associated Q-value to the action space
                    self.action_space.append({'content': content, 'q_value': q,  'slot':s, 'popularity':p})

        # For each non-neighbor UAV, add its generated content to the action space
        for uav in non_neighbor_uavs:
            for category, content_list in uav.generated_cache.items():
                for content in content_list:
                    # Initialize the Q-value for the content to 0
                    if content['content_type'] not in self.record:
                        self.record[content['content_type']] = {}
                    if content['content_coord'] not in self.record[content['content_type']]:
                        self.record[content['content_type']][content['content_coord']] = {}
                    if content['content_category'] not in self.record[content['content_type']][
                        content['content_coord']]:
                        self.record[content['content_type']][content['content_coord']][content['content_category']] = {}
                    if content['content_no'] not in self.record[content['content_type']][content['content_coord']][\
                        content['content_category']]:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][\
                            content['content_no']] = {
                            'weighted_request_tracking': 0,
                            'request_tracking': 0,
                            'content_hit': 0,
                            'q_value': 0,
                            'avg_reward': 0,
                            'no_f_time_cached': 0,
                            'slot':0
                        }
                    time_spent = (slot * 60) - content['generation_time']
                    if self.request_receive_count > 0:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][
                            content['content_no']] \
                            ['weighted_request_tracking'] \
                            = self.sigmoid((0.25 *
                                            self.record[content['content_type']][content['content_coord']][
                                                content['content_category']][content['content_no']] \
                                                ['weighted_request_tracking']) + 0.75 * (
                                                   self.record[content['content_type']][content['content_coord']][
                                                       content['content_category']][content['content_no']][
                                                       'request_tracking'] / self.request_receive_count))

                    p = self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']] \
                        ['weighted_request_tracking']
                    s = self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']]['slot']

                    q = self.sigmoid(self.record[content['content_type']][content['content_coord']][
                                         content['content_category']] \
                                         [content['content_no']]['avg_reward'])


                    self.record[content['content_type']][content['content_coord']][content['content_category']][
                                content['content_no']]['q_value'] = q

                    # Add content and associated Q-value to the action space
                    self.action_space.append({'content': content, 'q_value': q,  'slot': s, 'popularity': p})

        # Add content from content_cache to the action space
        for coord, coord_data in self.content_cache.items():
                for category, category_data in coord_data.items():
                    for content in category_data:
                    # Initialize the Q-value for the content to 0
                        if content['content_type'] not in self.record:
                            self.record[content['content_type']] = {}
                        if content['content_coord'] not in self.record[content['content_type']]:
                            self.record[content['content_type']][content['content_coord']] = {}
                        if content['content_category'] not in self.record[content['content_type']][
                            content['content_coord']]:
                            self.record[content['content_type']][content['content_coord']][
                                content['content_category']] = {}
                        if content['content_no'] not in self.record[content['content_type']][content['content_coord']][ \
                                content['content_category']]:
                            self.record[content['content_type']][content['content_coord']][content['content_category']][ \
                                content['content_no']] = {
                                'weighted_request_tracking': 0,
                                'request_tracking': 0,
                                'content_hit': 0,
                                'q_value': 0,
                                'avg_reward': 0,
                                'no_f_time_cached': 0,
                                'slot':0
                            }
                        time_spent = (slot * 60) - content['generation_time']
                    if self.request_receive_count > 0:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][
                            content['content_no']] \
                            ['weighted_request_tracking'] \
                            = self.sigmoid((0.25 *
                                            self.record[content['content_type']][content['content_coord']][
                                                content['content_category']][content['content_no']] \
                                                ['weighted_request_tracking']) + 0.75 * (
                                                   self.record[content['content_type']][content['content_coord']][
                                                       content['content_category']][content['content_no']][
                                                       'request_tracking'] / self.request_receive_count))

                    p = self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']] \
                        ['weighted_request_tracking']
                    s = self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']]['slot']

                    q = self.sigmoid(self.record[content['content_type']][content['content_coord']][
                                         content['content_category']] \
                                         [content['content_no']]['avg_reward'])

                    self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']]['q_value'] = q

                    # Add content and associated Q-value to the action space
                    self.action_space.append(
                        {'content': content, 'q_value': q,  'slot': s, 'popularity': p})

        #print(f"Action Space: { self.uav_id, len(self.action_space)}")
        # Print the total action space at the end of both loops
        for action in self.action_space:
            print(f'Content: {action["content"]}, Q-value: {action["q_value"]}')'''


    def select_action(self):    #MAB implementation
        # Clear the existing content cache
        self.clear_cache()

        remaining_cache_size = self.cache_size
        selected_actions = []


        average_q_value = sum(action['q_value'] for action in self.action_space) / (2 * len(self.action_space))

        # Start timing for decision latency measurement
        start_time = time.time()

        if random.random() < self.epsilon:
            # Exploration: Randomly choose content with q_value > average
            eligible_actions = [action for action in self.action_space if action['q_value'] > average_q_value]
            random.shuffle(eligible_actions)

            for action in eligible_actions:
                selected_content = action['content']
                content_size = selected_content['size']

                if remaining_cache_size - content_size >= 0.01:
                    s_type = selected_content['content_type']
                    s_coord = selected_content['content_coord']
                    s_category = selected_content['content_category']
                    s_no = selected_content['content_no']


                    if s_coord not in self.content_cache:
                        self.content_cache[s_coord] = {}

                    if s_category not in self.content_cache[s_coord]:
                        self.content_cache[s_coord][s_category] = []

                    if selected_content not in self.content_cache[s_coord][s_category]:
                        self.content_cache[s_coord][s_category].append(selected_content)
                        self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                    # Update the remaining cache size
                    remaining_cache_size -= content_size
                else:
                    #print("Cache size limit reached. Cannot add more content.")
                    break
        else:
            # Exploitation: Sort eligible actions based on q value
            eligible_actions = [action for action in self.action_space if action['q_value'] > average_q_value]
            eligible_actions.sort(key=lambda x: x['q_value'], reverse=True)

            for action in eligible_actions:
                selected_content = action['content']
                content_size = selected_content['size']

                if remaining_cache_size - content_size >= 0.01:
                    s_type = selected_content['content_type']
                    s_coord = selected_content['content_coord']
                    s_category = selected_content['content_category']
                    s_no = selected_content['content_no']

                    if s_coord not in self.content_cache:
                        self.content_cache[s_coord] = {}

                    if s_category not in self.content_cache[s_coord]:
                        self.content_cache[s_coord][s_category] = []

                    if selected_content not in self.content_cache[s_coord][s_category]:
                        self.content_cache[s_coord][s_category].append(selected_content)
                        self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                    # Update the remaining cache size
                    remaining_cache_size -= content_size
                else:
                    #print("Cache size limit reached. Cannot add more content.")
                    break

        # Measure decision latency
        decision_latency = time.time() - start_time

        # Update only if decision latency is > 0
        if decision_latency > 0:
            self.avg_decision_latency += decision_latency
            self.decision_count += 1

        print(f"Decision Latency for UAV {self.uav_id}: {decision_latency:.6f} seconds")
        return



    '''def select_action(self):  #LRU
        # Clear the existing content cache
        self.clear_cache()
        remaining_cache_size = self.cache_size
        selected_actions = []

        # Start timing for decision latency measurement
        start_time = time.time()

        # Sort actions based on 's' values in descending order
        sorted_actions = sorted(self.action_space, key=lambda action: action['slot'], reverse=True)

        for action in sorted_actions:
            selected_content = action['content']
            content_size = selected_content['size']

            s_type = selected_content['content_type']
            s_coord = selected_content['content_coord']
            s_category = selected_content['content_category']
            s_no = selected_content['content_no']

            if s_coord not in self.content_cache:
                self.content_cache[s_coord] = {}

            if s_category not in self.content_cache[s_coord]:
                self.content_cache[s_coord][s_category] = []

            if selected_content not in self.content_cache[s_coord][s_category]:
                self.content_cache[s_coord][s_category].append(selected_content)
                self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                # Update the remaining cache size
                remaining_cache_size -= content_size

                # Check if cache size is overwhelmed
                if remaining_cache_size < 0.01:
                    break

        # If cache size is still not overwhelmed and there are items with 's' value 0, choose randomly
        if remaining_cache_size > 0.01:
            zero_s_value_actions = [action for action in sorted_actions if action['slot'] == 0]
            random_action = random.choice(zero_s_value_actions)

            for action in zero_s_value_actions:
                selected_content = random_action['content']
                content_size = selected_content['size']

                s_type = selected_content['content_type']
                s_coord = selected_content['content_coord']
                s_category = selected_content['content_category']
                s_no = selected_content['content_no']

                if s_coord not in self.content_cache:
                    self.content_cache[s_coord] = {}

                if s_category not in self.content_cache[s_coord]:
                    self.content_cache[s_coord][s_category] = []

                if selected_content not in self.content_cache[s_coord][s_category]:
                    self.content_cache[s_coord][s_category].append(selected_content)
                    self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                    # Update the remaining cache size
                    remaining_cache_size -= content_size

                    # Check if cache size is overwhelmed
                    if remaining_cache_size < 0.01:
                        break

        # Measure decision latency
        decision_latency = time.time() - start_time

        # Update only if decision latency is > 0
        if decision_latency > 0:
            self.avg_decision_latency += decision_latency
            self.decision_count += 1


        return'''

    '''def select_action(self):  #Popularity
            # Clear the existing content cache
            self.clear_cache()
            remaining_cache_size = self.cache_size
            selected_actions = []
            
            # Start timing for decision latency measurement
            start_time = time.time()

            # Sort actions based on 'popularity' values in descending order
            sorted_actions = sorted(self.action_space, key=lambda action: action['popularity'], reverse=True)
            

            for action in sorted_actions:
                selected_content = action['content']
                content_size = selected_content['size']

                s_type = selected_content['content_type']
                s_coord = selected_content['content_coord']
                s_category = selected_content['content_category']
                s_no = selected_content['content_no']

                if s_coord not in self.content_cache:
                    self.content_cache[s_coord] = {}

                if s_category not in self.content_cache[s_coord]:
                    self.content_cache[s_coord][s_category] = []

                if selected_content not in self.content_cache[s_coord][s_category]:
                    self.content_cache[s_coord][s_category].append(selected_content)
                    self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                    # Update the remaining cache size
                    remaining_cache_size -= content_size

                    # Check if cache size is overwhelmed
                    if remaining_cache_size < 0.01:
                        break

            # If cache size is still not overwhelmed and there are items with 's' value 0, choose randomly
            if remaining_cache_size > 0.01:
                zero_s_value_actions = [action for action in sorted_actions if action['popularity'] == 0]
                random_action = random.choice(zero_s_value_actions)

                for action in zero_s_value_actions:
                    selected_content = random_action['content']
                    content_size = selected_content['size']

                    s_type = selected_content['content_type']
                    s_coord = selected_content['content_coord']
                    s_category = selected_content['content_category']
                    s_no = selected_content['content_no']

                    if s_coord not in self.content_cache:
                        self.content_cache[s_coord] = {}

                    if s_category not in self.content_cache[s_coord]:
                        self.content_cache[s_coord][s_category] = []

                    if selected_content not in self.content_cache[s_coord][s_category]:
                        self.content_cache[s_coord][s_category].append(selected_content)
                        self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                        # Update the remaining cache size
                        remaining_cache_size -= content_size

                        # Check if cache size is overwhelmed
                        if remaining_cache_size < 0.01:
                            break
                            
        # Measure decision latency
        decision_latency = time.time() - start_time

        # Update only if decision latency is > 0
        if decision_latency > 0:
            self.avg_decision_latency += decision_latency
            self.decision_count += 1

        return'''

    def clear_cache(self):
        # Clear the existing content cache
        self.content_cache = {}

    def get_reward(self):
        # Define the reward function based on the selected action and content popularity
        for entity_type, coord_dict in self.record.items():
            for coord, category_dict in coord_dict.items():
                for category, content_no_dict in category_dict.items():
                    for content_no, content_info in content_no_dict.items():
                        if self.is_content_in_cache(coord, category, content_no):
                            avg_reward_value = content_info.get('avg_reward', 0)
                            q = content_info.get('q_value', 0)
                            c = content_info.get('no_f_time_cached', 0)
                            h = content_info.get('content_hit', 0)
                            if h > 0 and c > 0:
                                avg_reward_value = avg_reward_value - (avg_reward_value - (h * q)) / c
                                self.record[entity_type][coord][category][content_no]['avg_reward'] = avg_reward_value
                        self.record[entity_type][coord][category][content_no]['q_value'] = 0
                        self.content_hit += self.record[entity_type][coord][category][content_no]['content_hit']
                        self.record[entity_type][coord][category][content_no]['content_hit'] = 0
        # print(f"reward: {self.content_hit}")
        return

    def is_content_in_cache(self, coord, category, content_no):
        # Add your logic to check if content is in content_cache
        # For example, assuming content_cache is a dictionary of the form:
        # {entity_type: {coord: {category: [content1, content2, ...]}}}
        return (
                coord in self.content_cache
                and category in self.content_cache[coord]
                and any(content['content_no'] == content_no for content in self.content_cache[coord][category])
        )

    def is_within_coverage(self, x, y):  # location of has different validity c vehicles
        (x1, y1), (x2, y2) = self.coverage_area
        return x1 <= x < x2 and y1 <= y < y2  # checks if vehicle falls in uav's range

    def get_connected_satellites(self, communication_schedule, target_slot):
        connected_satellites = []

        if target_slot in communication_schedule:
            connected_satellites = communication_schedule[target_slot]

        return connected_satellites

    def send_update_to_federated_server(self):
        """
        Sends the vehicles Q-values to the federated server.
        """
        self.aggregator.receive_local_update(self.uav_id, self.record)

    def run(self, current_time, communication, communication_schedule, slot, satellites, no_of_content_each_category,
            uav_content_generation_period, epsilon, uavs):
        self.cache_cleanup(current_time)
        self.current_slot = slot
        if (slot - 1) % uav_content_generation_period == 0:
            self.request_tracking = {}  # Reset the request tracking data structure to an empty dictionary
            self.request_receive_count = 0
            # print('run', slot)
            self.generate_content(slot, current_time, no_of_content_each_category)
            if slot > 10:
                self.get_reward()
            # we want to cache the content only  during the multiple of 10th slot, so that from the (n*10)+1 th slot the cached content are available
            self.cache_content(communication, communication_schedule, slot, uavs,
                               satellites)  # while the loop is in 11th we are giving the slot no 10 becase we are eager to cache the content those would be out of range after 10th slot
            self.send_update_to_federated_server()
        #self.print_cache()
            if slot % 60 == 0:
                self.update_zipf(slot)
