
import random
import math
import time
import numpy as np

class Vehicle:
    def __init__(self, vehicle_id, grid_size, vehicle_range, vehicle_speed,  aggregator):
        self.vehicle_id = vehicle_id
        self.grid_size = grid_size
        self.vehicle_speed= vehicle_speed
        self.v_range=vehicle_range
        #self.current_location = (random.randint(0, grid_size-1), random.randint(0, grid_size-1))
        self.content_categories = ['II', 'III', 'IV']   # Content categories generated by the vehicle
        self.content_size = {'I':10, 'II': 1, 'III': 0.01, 'IV': 2}  #sizes of content as per category MB
        self.cache_size = 50 #Mbytes
        self.transmission_rate= 6 #Mbps
        # Initialize counters for requests generated per category and received content per category
        self.requests_generated_per_category = {category: 0 for category in self.content_categories}
        self.content_received_count_per_category = {category: 0 for category in self.content_categories}
        self.content_cache = { }  # Cache to store content received from satellites and other UAVs
        self.active_requests = set()  # Set to store active content requests
        self.cache_cleanup_interval = 60  # Cache cleanup interval in seconds
        self.content_cache = {}  # Cache to store content received from satellites and other UAVs
        self.epsilon = 0.1  # Epsilon value for epsilon-greedy strategy
        # 1. Define the Action Space
        self.num_actions = 0  # Initialize the number of actions to zero
        # A list to keep track of the available content categories
        self.action_space = []
        self.generated_cache = {
            'II': [],
            'III': [],
            'IV': []  # Add more categories if needed
        }
        # Initialize the request tracking data structure
        self.record = {}  # An empty dictionary to track content request an content
        # self.global_rrequest_tracking = {} #an empty dictionary to track request in whole simulation time
        self.request_receive = 0
        self.request_receive_cache =0
        self.content_cache_hit = 0
        self.content_hit_from_source = 0
        self.global_request_receive_count = 0
        self.num_context_parameters = 3
        self.avg_decision_latency = 0
        self.decision_count = 0
        self.aggregator = aggregator


    def cache_cleanup(self, current_time):
        for category in self.content_categories:
            if category in self.content_cache.items():
                cached_content = self.content_cache[category]
            # Filter out content that has expired
                self.content_cache[category] = [content for content in cached_content if
                                            current_time < content['generation_time'] + content['content_validity']]
                '''for content in cached_content:
                    # if current_time >= content['generation_time'] + content['content_validity']:
                    print(
                        f"Expired Content - Generation Time: {content['generation_time']}, Current Time: {current_time}",
                        end=' ')
                    '''

    def sigmoid(self, x):
        return 1 / (1 + math.exp(-x))

    def move(self):
        # Generate random direction: 0 = up, 1 = down, 2 = left, 3 = right
        direction = random.randint(0, 3)
        if direction == 0 and self.current_location[1] > 0:
            self.current_location = (self.current_location[0], self.current_location[1] - self.vehicle_speed)
        elif direction == 1 and self.current_location[1] < self.grid_size - 1:
            self.current_location = (self.current_location[0], self.current_location[1] + self.vehicle_speed)
        elif direction == 2 and self.current_location[0] > 0:
            self.current_location = (self.current_location[0] - self.vehicle_speed, self.current_location[1])
        elif direction == 3 and self.current_location[0] < self.grid_size - 1:
            self.current_location = (self.current_location[0] + self.vehicle_speed, self.current_location[1])

        #print(f"Vehicle {self.vehicle_id} moved to {self.current_location}")


    def is_within_range(self, other_location):
        x1, y1 = self.current_location
        x2, y2 = other_location
        return abs(x1 - x2) <= self.v_range and abs(y1 - y2) <= self.v_range

    def get_content_size(self, entity):
            return self.content_size.get(entity, 0)


    def process_content_request(self, communication, content_request, slot, grid_size, flag):
        print('hi')
        requested_entity_type = content_request['type']
        requested_coord = content_request['coord']
        requested_category = content_request['category']
        requested_content_no = content_request['no']
        self.request_receive += 1
        self.global_request_receive_count += 1
        # Update the request tracking data structure
        if requested_entity_type not in self.record:
            self.record[requested_entity_type] = {}
        if requested_coord not in self.record[requested_entity_type]:
            self.record[requested_entity_type][requested_coord] = {}
        if requested_category not in self.record[requested_entity_type][requested_coord]:
            self.record[requested_entity_type][requested_coord][requested_category] = {}
        if requested_content_no not in self.record[requested_entity_type][requested_coord][requested_category]:
            self.record[requested_entity_type][requested_coord][requested_category][requested_content_no] = {
                'weighted_request_tracking': 0,
                'request_tracking': 0,
                'content_hit': 0,
                'q_value': 0,
                'avg_reward': 0,
                'no_f_time_cached': 0,
                'slot': 0
            }
        self.record[requested_entity_type][requested_coord][requested_category][requested_content_no]['request_tracking'] += 1
        content_request['vehicle_list'].append(self.vehicle_id)


        if requested_entity_type == "satellite" or requested_entity_type == "UAV":
                self.request_receive_cache += 1
                content = self.find_cache(communication, content_request, slot)
                if content:
                    if flag==0:
                        communication.content_hit += 1
                    if communication.content_received_time > (content_request['hop_count'] * random.uniform(0, 0.001)) + (content_request['hop_count'] * ((content['size'] * 8) / self.transmission_rate)):
                        communication.content_received_time = (content_request['hop_count'] * random.uniform(0, 0.001)) + (content_request['hop_count'] * ((content['size'] * 8) / self.transmission_rate))
                    return True
                else:
                    return False
        if requested_entity_type == "grid":
            if self.is_within_range(communication.get_coordinates_from_index(requested_coord, grid_size)):
                content=self.generate_content(communication, content_request, slot)
                if content:
                    communication.content_received_time = (content_request['hop_count'] * random.uniform(0, 0.001)) + (content_request['hop_count']*((content['size'] * 8) / self.transmission_rate))
                return True
            else:
                self.request_receive_cache += 1
                content=self.find_cache(communication, content_request, slot)
                if content:
                    if flag==0:
                        communication.content_hit += 1
                    if communication.content_received_time > (content_request['hop_count'] * random.uniform(0, 0.001)) + (content_request['hop_count'] * ((content['size'] * 8) / self.transmission_rate)):
                            communication.content_received_time > (content_request['hop_count'] * random.uniform(0, 0.001)) + (
                                content_request['hop_count'] * ((content['size'] * 8) / self.transmission_rate))

                    return True
                else:
                    return False

    def generate_content(self, communication, content_request,  slot):
        #print('generate content')
        content_validity = 10 * 60  # 10 minutes in seconds
        # Get the content category and size based on the request
        content_category = content_request['category']
        content_size = self.content_size.get(content_category, 0)  # Default to 0 if category is not found
        request_recieve_time=content_request['g_time'] + (content_request['hop_count'] * 0.001)
        content_request['time_spent']=request_recieve_time
        content = {
            'unique_id': content_request['unique_id'],
            'destination': content_request['requesting_vehicle'],
            'generation_time': request_recieve_time ,
            'hop_count': 0,
            'content_type': 'grid',  # You can specify the content type here
            'content_category': content_category,
            'content_coord': content_request['coord'],
            'content_no': content_request['no'],
            'content_validity': content_validity,
            'content_receive_time': 0,
            'size': content_size  # Include the content size based on category
        }
        self.content_hit_from_source += 1
        self.update_action_space(content, slot, federated_update=False) # cache the content

    def forward_content(self, content_request, content, vehicles, base_stations, communication,
                        slot):  # for the first time
        print('forward content')
        # step 1: check the vehicles in range

        for v in vehicles:
            if self != v and v.is_within_range(self.current_location):
                content_copy = copy.deepcopy(content)
                # content is received by vehicle
                # simulate the content transmission delay and processing time
                # Simulate the content transmission delay and processing time for this specific vehicle
                content_copy['receive_time'] += content_copy['generation_time'] + (
                            (content_copy['size'] * 8) / self.transmission_rate)  # Convert to seconds
                content_copy['hop_count'] += 1  # Increase hop count for this copy
                print(f"Vehicle {self.vehicle_id} forwarded content to {v.vehicle_id}")
                # cache the content
                # self.update_action_space(content, slot):  # cache the content
                if content['destination'] == v.vehicle_id:
                    # Increase the content_received_count_per_categorif content['destination'] == self.vehicle_id:
                    if communication.content_received_time > content_copy[receive_time]:
                        communication.content_received_time = content_copy[receive_time]

                for bs in base_stations:
                    if bs.check_within_range(vehicle.current_location):
                        bs.update_action_space(content, slot)

                    else:
                        if content_copy['hop_count'] < 4:
                        # Continue forwarding the content to the next vehicle
                            v.forward_content(content_copy, vehicles, communication)

            else:
                return

    def should_cache_content(self):
        # Implement your probabilistic approach to determine whether to cache the content or not
        # Check if there is space in the content cache
        total_cached_size = sum([len(c) for c in self.content_cache.values()])
        if total_cached_size >= self.cache_size:  # Cache is full, cannot cache more conten
            pass


    def cache_content(self, content):
        category = content['content_category']
        if category not in self.content_cache:
            self.content_cache[category] = []
            self.content_cache[category].append(content)
        #print(f"Vehicle {self.vehicle_id} cached content: {content}")


    def find_cache(self, communication, content_request, slot):
        type = content_request['type']
        coord = content_request['coord']
        category = content_request['category']

        if coord in self.content_cache:
            if category in self.content_cache[coord]:
                category_cache = self.content_cache[coord][category]
                for content in category_cache:
                    if content['content_no'] == content_request['no']:
                            self.track_content_hit(content, slot)
                            return content
        return None

    def track_content_hit(self, content, slot):
        #print('track_content_hit')
        content_type = content['content_type']
        content_coord = content['content_coord']
        content_category = content['content_category']
        content_no = content['content_no']

        if content_type not in self.record:
            self.record[content_type] = {}

        if content_coord not in self.record[content_type]:
            self.record[content_type][content_coord] = {}

        if content_category not in self.record[content_type][content_coord]:
            self.record[content_type][content_coord][content_category] = {}

        if content_no not in self.record[content_type][content_coord][content_category]:
            self.record[content_type][content_coord][content_category][content_no] = {
                    'global_request_tracking': 0,
                    'request_tracking': 0,
                    'content_hit': 0,
                    'q_value': 0,
                    'avg_reward': 0,
                    'no_f_time_cached':0,
                    'slot':0
            }

        # Update the content hit information
        self.record[content_type][content_coord][content_category][content_no]['content_hit'] += 1
        self.record[content_type][content_coord][content_category][content_no]['slot'] = slot
        #print(f"track_content_hi    t: {.record[content_type][content_coord][content_category][content_no]['content_hit']}")
        return{self.record[content_type][content_coord][content_category][content_no]['content_hit']}



    def send_request_to_bs_thread(self, bs, content_request):
        bs.receive_request(content_request)


    def update_action_space(self, content, slot, federated_update=True): #ucb mab
    # Initialize the Q-value for the content to 0
    # Add content and its associated Q-value
            if content['content_type'] not in self.record:
                self.record[content['content_type']]={}
            if content['content_coord'] not in self.record[content['content_type']]:
                self.record[content['content_type']][content['content_coord']]={}
            if content['content_category'] not in self.record[content['content_type']][content['content_coord']]:
                self.record[content['content_type']][content['content_coord']][content['content_category']]={}
            if content['content_no'] not in self.record[content['content_type']][content['content_coord']][content['content_category']]:
                self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']]= {
                                'weighted_request_tracking': 0,
                                'request_tracking': 0,
                                'content_hit': 0,
                                'q_value': 0,
                                'avg_reward': 0,
                                'no_f_time_cached':0,
                                'slot': 0
                            }
            time_spent=(slot*60) - content['generation_time']
            if self.request_receive > 0:
                self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']]\
                    ['weighted_request_tracking'] \
                    = self.sigmoid((0.25 *
                       self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']]  \
                           ['weighted_request_tracking']) + 0.75 * (
                      self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']][
                          'request_tracking']/self.request_receive))

            p = self.record[content['content_type']][content['content_coord']][content['content_category']][
                content['content_no']] \
                ['weighted_request_tracking']
            s = max(1, self.record[content['content_type']][content['content_coord']]
            [content['content_category']][content['content_no']]['slot'])  # Ensure s >= 1

            no_f_time_cached = max(1, self.record[content['content_type']][content['content_coord']]
            [content['content_category']][content['content_no']]['no_f_time_cached'])  # Ensure >=1

            ucb = np.sqrt((2 * np.log(s)) / no_f_time_cached)  # Now always valid

            local_q_value = self.sigmoid(self.record[content['content_type']][content['content_coord']]
                                         [content['content_category']][content['content_no']]['avg_reward'] +
                                         (self.cache_size / content['size']) +
                                         ((content['content_validity'] - time_spent) / content['content_validity']) +
                                         self.record[content['content_type']][content['content_coord']]
                                         [content['content_category']][content['content_no']][
                                             'weighted_request_tracking'])
            if federated_update:
                federated_q_value = self.aggregator.get_federated_q_value(content)
                q = 0.5 * local_q_value + 0.5 * federated_q_value + ucb  # Weighted Combination
            else:
                q = local_q_value + ucb

            self.record[content['content_type']][content['content_coord']][content['content_category']][
                content['content_no']]['q_value'] = q

    # Add content and associated Q-value to the action space
            self.action_space.append(
                {'content': content, 'q_value': q, 'slot': s, 'popularity': p})
            return

    '''def update_action_space(self, content, slot, federated_update=False): #mab and all
        # Initialize the Q-value for the content to 0
        # Add content and its associated Q-value
        if content['content_type'] not in self.record:
            self.record[content['content_type']] = {}
        if content['content_coord'] not in self.record[content['content_type']]:
            self.record[content['content_type']][content['content_coord']] = {}
        if content['content_category'] not in self.record[content['content_type']][content['content_coord']]:
            self.record[content['content_type']][content['content_coord']][content['content_category']] = {}
        if content['content_no'] not in self.record[content['content_type']][content['content_coord']][
            content['content_category']]:
            self.record[content['content_type']][content['content_coord']][content['content_category']][
                content['content_no']] = {
                'weighted_request_tracking': 0,
                'request_tracking': 0,
                'content_hit': 0,
                'q_value': 0,
                'avg_reward': 0,
                'no_f_time_cached': 0,
                'slot': 0
            }
        time_spent = (slot * 60) - content['generation_time']
        if self.request_receive > 0:
            self.record[content['content_type']][content['content_coord']][content['content_category']][
                content['content_no']] \
                ['weighted_request_tracking'] \
                = self.sigmoid((0.25 *
                                self.record[content['content_type']][content['content_coord']][
                                    content['content_category']][content['content_no']] \
                                    ['weighted_request_tracking']) + 0.75 * (
                                       self.record[content['content_type']][content['content_coord']][
                                           content['content_category']][content['content_no']][
                                           'request_tracking'] / self.request_receive))

        p = self.record[content['content_type']][content['content_coord']][content['content_category']][
            content['content_no']] \
            ['weighted_request_tracking']
        s = self.record[content['content_type']][content['content_coord']][content['content_category']][
            content['content_no']]['slot']

        q = self.sigmoid(self.record[content['content_type']][content['content_coord']][
                             content['content_category']] \
                             [content['content_no']]['avg_reward'])

        self.record[content['content_type']][content['content_coord']][content['content_category']][
            content['content_no']]['q_value'] = q

        # Add content and associated Q-value to the action space
        self.action_space.append({'content': content, 'q_value': q, 'slot': s, 'popularity': p})
        return'''

    def append_action_space(self, slot, federated_update=True):
        # Add content from content_cache to the action space
        for coord, coord_data in self.content_cache.items():
            for category, category_data in coord_data.items():
                for content in category_data:
                    # Initialize the Q-value for the content to 0
                    if content['content_type'] not in self.record:
                        self.record[content['content_type']] = {}
                    if content['content_coord'] not in self.record[content['content_type']]:
                        self.record[content['content_type']][content['content_coord']] = {}
                    if content['content_category'] not in self.record[content['content_type']][
                        content['content_coord']]:
                        self.record[content['content_type']][content['content_coord']][
                            content['content_category']] = {}
                    if content['content_no'] not in self.record[content['content_type']][content['content_coord']][ \
                            content['content_category']]:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][ \
                            content['content_no']] = {
                            'weighted_request_tracking': 0,
                            'request_tracking': 0,
                            'content_hit': 0,
                            'q_value': 0,
                            'avg_reward': 0,
                            'no_f_time_cached': 0,
                            'slot': 0
                        }
                    time_spent = (slot * 60) - content['generation_time']
                    if self.request_receive > 0:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][
                            content['content_no']] \
                            ['weighted_request_tracking'] \
                            = self.sigmoid((0.25 *
                                            self.record[content['content_type']][content['content_coord']][
                                                content['content_category']][content['content_no']] \
                                                ['weighted_request_tracking']) + 0.75 * (
                                                   self.record[content['content_type']][content['content_coord']][
                                                       content['content_category']][content['content_no']][
                                                       'request_tracking'] / self.request_receive))

                    p = self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']] \
                        ['weighted_request_tracking']
                    s = max(1, self.record[content['content_type']][content['content_coord']]
                    [content['content_category']][content['content_no']]['slot'])  # Ensure s >= 1

                    no_f_time_cached = max(1, self.record[content['content_type']][content['content_coord']]
                    [content['content_category']][content['content_no']]['no_f_time_cached'])  # Ensure >=1

                    ucb = np.sqrt((2 * np.log(s)) / no_f_time_cached)  # Now always valid

                    local_q_value = self.sigmoid(self.record[content['content_type']][content['content_coord']]
                                                 [content['content_category']][content['content_no']]['avg_reward'] +
                                                 (self.cache_size / content['size']) +
                                                 ((content['content_validity'] - time_spent) / content[
                                                     'content_validity']) +
                                                 self.record[content['content_type']][content['content_coord']]
                                                 [content['content_category']][content['content_no']][
                                                     'weighted_request_tracking'])
                    if federated_update:
                        federated_q_value = self.aggregator.get_federated_q_value(content)
                        q = 0.5 * local_q_value + 0.5 * federated_q_value + ucb  # Weighted Combination
                    else:
                        q = local_q_value + ucb

                    self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']]['q_value'] = q

                    # Add content and associated Q-value to the action space
                    self.action_space.append(
                        {'content': content, 'q_value': q, 'slot': s, 'popularity': p})

    def select_action(self):    #MAB implementation
        # Clear the existing content cache
        #self.clear_cache()

        remaining_cache_size = self.cache_size
        selected_actions = []

        average_q_value = sum(action['q_value'] for action in self.action_space) / (2 * len(self.action_space))

        if random.random() < self.epsilon:
            # Exploration: Randomly choose content with q_value > average
            eligible_actions = [action for action in self.action_space if action['q_value'] > average_q_value]
            random.shuffle(eligible_actions)

            for action in eligible_actions:
                selected_content = action['content']
                content_size = selected_content['size']

                if remaining_cache_size - content_size >= 0.01:
                    s_type = selected_content['content_type']
                    s_coord = selected_content['content_coord']
                    s_category = selected_content['content_category']
                    s_no = selected_content['content_no']


                    if s_coord not in self.content_cache:
                        self.content_cache[s_coord] = {}

                    if s_category not in self.content_cache[s_coord]:
                        self.content_cache[s_coord][s_category] = []

                    if selected_content not in self.content_cache[s_coord][s_category]:
                        self.content_cache[s_coord][s_category].append(selected_content)
                        self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                    # Update the remaining cache size
                    remaining_cache_size -= content_size
                else:
                    #print("Cache size limit reached. Cannot add more content.")
                    break
        else:
            # Exploitation: Sort eligible actions based on q value
            eligible_actions = [action for action in self.action_space if action['q_value'] > average_q_value]
            eligible_actions.sort(key=lambda x: x['q_value'], reverse=True)

            for action in eligible_actions:
                selected_content = action['content']
                content_size = selected_content['size']

                if remaining_cache_size - content_size >= 0.01:
                    s_type = selected_content['content_type']
                    s_coord = selected_content['content_coord']
                    s_category = selected_content['content_category']
                    s_no = selected_content['content_no']

                    if s_coord not in self.content_cache:
                        self.content_cache[s_coord] = {}

                    if s_category not in self.content_cache[s_coord]:
                        self.content_cache[s_coord][s_category] = []

                    if selected_content not in self.content_cache[s_coord][s_category]:
                        self.content_cache[s_coord][s_category].append(selected_content)
                        self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                    # Update the remaining cache size
                    remaining_cache_size -= content_size
                else:
                    #print("Cache size limit reached. Cannot add more content.")
                    break

        return

    '''def select_action(self):  #LRU
        # Clear the existing content cache
        remaining_cache_size = self.cache_size
        selected_actions = []

        # Sort actions based on 's' values in descending order
        sorted_actions = sorted(self.action_space, key=lambda action: action['slot'], reverse=True)

        for action in sorted_actions:
            selected_content = action['content']
            content_size = selected_content['size']

            s_type = selected_content['content_type']
            s_coord = selected_content['content_coord']
            s_category = selected_content['content_category']
            s_no = selected_content['content_no']

            if s_coord not in self.content_cache:
                self.content_cache[s_coord] = {}

            if s_category not in self.content_cache[s_coord]:
                self.content_cache[s_coord][s_category] = []

            if selected_content not in self.content_cache[s_coord][s_category]:
                self.content_cache[s_coord][s_category].append(selected_content)
                self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                # Update the remaining cache size
                remaining_cache_size -= content_size

                # Check if cache size is overwhelmed
                if remaining_cache_size < 0.01:
                    break

        # If cache size is still not overwhelmed and there are items with 's' value 0, choose randomly
        if remaining_cache_size > 0.01:
            zero_s_value_actions = [action for action in sorted_actions if action['slot'] == 0]
            if(zero_s_value_actions):
                random_action = random.choice(zero_s_value_actions)
            else:
                return

            for action in zero_s_value_actions:
                selected_content = random_action['content']
                content_size = selected_content['size']

                s_type = selected_content['content_type']
                s_coord = selected_content['content_coord']
                s_category = selected_content['content_category']
                s_no = selected_content['content_no']

                if s_coord not in self.content_cache:
                    self.content_cache[s_coord] = {}

                if s_category not in self.content_cache[s_coord]:
                    self.content_cache[s_coord][s_category] = []

                if selected_content not in self.content_cache[s_coord][s_category]:
                    self.content_cache[s_coord][s_category].append(selected_content)
                    self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                    # Update the remaining cache size
                    remaining_cache_size -= content_size

                    # Check if cache size is overwhelmed
                    if remaining_cache_size < 0.01:
                        break

        return'''

    '''def select_action(self):  #Popularity
            # Clear the existing content cache
            self.clear_cache()
            remaining_cache_size = self.cache_size
            selected_actions = []

            # Sort actions based on 'popularity' values in descending order
            sorted_actions = sorted(self.action_space, key=lambda action: action['popularity'], reverse=True)

            for action in sorted_actions:
                selected_content = action['content']
                content_size = selected_content['size']

                s_type = selected_content['content_type']
                s_coord = selected_content['content_coord']
                s_category = selected_content['content_category']
                s_no = selected_content['content_no']

                if s_coord not in self.content_cache:
                    self.content_cache[s_coord] = {}

                if s_category not in self.content_cache[s_coord]:
                    self.content_cache[s_coord][s_category] = []

                if selected_content not in self.content_cache[s_coord][s_category]:
                    self.content_cache[s_coord][s_category].append(selected_content)
                    self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                    # Update the remaining cache size
                    remaining_cache_size -= content_size

                    # Check if cache size is overwhelmed
                    if remaining_cache_size < 0.01:
                        break

            # If cache size is still not overwhelmed and there are items with 's' value 0, choose randomly
            if remaining_cache_size > 0.01:
                zero_s_value_actions = [action for action in sorted_actions if action['slot'] == 0]
                if (zero_s_value_actions):
                    random_action = random.choice(zero_s_value_actions)
                else:
                    return

                for action in zero_s_value_actions:
                    selected_content = random_action['content']
                    content_size = selected_content['size']

                    s_type = selected_content['content_type']
                    s_coord = selected_content['content_coord']
                    s_category = selected_content['content_category']
                    s_no = selected_content['content_no']

                    if s_coord not in self.content_cache:
                        self.content_cache[s_coord] = {}

                    if s_category not in self.content_cache[s_coord]:
                        self.content_cache[s_coord][s_category] = []

                    if selected_content not in self.content_cache[s_coord][s_category]:
                        self.content_cache[s_coord][s_category].append(selected_content)
                        self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                        # Update the remaining cache size
                        remaining_cache_size -= content_size

                        # Check if cache size is overwhelmed
                        if remaining_cache_size < 0.01:
                            break

            return'''

    def get_reward(self):
        # Define the reward function based on the selected action and content popularity
        for entity_type, coord_dict in self.record.items():
            for coord, category_dict in coord_dict.items():
                for category, content_no_dict in category_dict.items():
                    for content_no, content_info in content_no_dict.items():
                        if self.is_content_in_cache(coord, category, content_no):
                            avg_reward_value = content_info.get('avg_reward', 0)
                            q = content_info.get('q_value', 0)
                            c = content_info.get('no_f_time_cached', 0)
                            h = content_info.get('content_hit', 0)
                            if h > 0 and c > 0:
                                avg_reward_value = avg_reward_value - (avg_reward_value - (h * q)) / c
                                self.record[entity_type][coord][category][content_no]['avg_reward'] = avg_reward_value
                        self.record[entity_type][coord][category][content_no]['q_value'] = 0
                        self.content_cache_hit += self.record[entity_type][coord][category][content_no]['content_hit']
                        self.record[entity_type][coord][category][content_no]['content_hit'] = 0
        # print(f"reward: {self.content_hit}")
        return

    def is_content_in_cache(self, coord, category, content_no):
        # Add your logic to check if content is in content_cache
        # For example, assuming content_cache is a dictionary of the form:
        # {entity_type: {coord: {category: [content1, content2, ...]}}}
        return (
                coord in self.content_cache
                and category in self.content_cache[coord]
                and any(content['content_no'] == content_no for content in self.content_cache[coord][category])
        )

    def clear_cache(self):
        # Clear the existing content cache
        self.content_cache = {}

    def send_update_to_federated_server(self):
        """
        Sends the vehicleâ€™s Q-values to the federated server.
        """
        self.aggregator.receive_local_update(self.vehicle_id, self.record)

    def run(self, current_time, slot, time_slots, vehicles, uavs, base_stations, satellites, communication, grid_size,
            no_of_request_genertaed_in_each_timeslot, no_of_content_each_category):
        self.cache_cleanup(current_time)
        if ((slot - 1) % 10 == 0):
            if slot > 10:
                self.append_action_space(slot, federated_update=False)
                if len(self.action_space):
                    self.select_action()
                    self.action_space = []
                self.send_update_to_federated_server()
            if slot > 20:
                self.get_reward()

        self.move()
        for uav in uavs:  # check under which uav this vehicle is travelling # chnages for spatio-temporal
            if uav.is_within_coverage(self.current_location[0], self.current_location[1]):
                for _ in range(no_of_request_genertaed_in_each_timeslot):
                    content_request = communication.send_content_request(self, vehicles, uavs, base_stations,
                                                                         satellites,
                                                                         grid_size, current_time, slot,
                                                                         no_of_content_each_category, uav.current_zipf)


                if (content_request['unique_id'] != 0):
                    self.active_requests.add(content_request['unique_id'])
                    communication.content_request_queue.put(content_request)

