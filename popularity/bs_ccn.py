
import random
import math
import numpy as np


class BaseStation:
    def __init__(self, bs_id, bs_range, grid_size, aggregator):
        self.grid_size = grid_size
        self.bs_id = bs_id
        self.b_range = bs_range
        self.current_location = (random.randint(0, grid_size - 1), random.randint(0, grid_size - 1))
        self.content_cache = {}  # Dictionary to store cached content
        self.content_categories = ['I', 'II', 'III', 'IV']  # Content categories generated by the vehicle
        self.content_size = {'I': 10, 'II': 1, 'III': 0.01, 'IV': 2}  # sizes of content as per category
        self.cache_size = 300  # Mbytes
        self.transmission_rate = 15  # Mbps
        self.content_cache = {}  # Cache to store content received from satellites and other UAVs
        # Initialize counters for requests generated per category and received content per category
        self.requests_generated_per_category = {category: 0 for category in self.content_categories}
        self.content_received_count_per_category = {category: 0 for category in self.content_categories}
        self.active_requests = set()  # Set to store active content requests
        self.cache_cleanup_interval = 60  # Cache cleanup interval in seconds
        self.content_cache = {}  # Cache to store content received from satellites and other UAVs
        self.epsilon = 0.1  # Epsilon value for epsilon-greedy strategy
        # 1. Define the Action Space
        self.num_actions = 0  # Initialize the number of actions to zero
        # A list to keep track of the available content categories
        self.action_space = []
        self.generated_cache = {
            'II': [],
            'III': [],
            'IV': []  # Add more categories if needed
        }
        # Initialize the request tracking data structure
        self.record = {}  # An empty dictionary to track content request an content
        # self.global_rrequest_tracking = {} #an empty dictionary to track request in whole simulation time
        self.content_cache_hit = 0
        self.num_context_parameters = 3
        self.request_receive = 0
        self.request_receive_cache = 0
        self.content_hit_from_source = 0
        self.content_hit_from_gs = 0
        self.content_hit_from_indirect_source = 0
        self.global_request_receive_count = 0
        self.aggregator = aggregator

    def get_content_size(self, entity):
        return self.content_size.get(entity, 0)

    def cache_cleanup(self, current_time):
        for category in self.content_categories:
            if category in self.content_cache.items():
                cached_content = self.content_cache[category]
                # Filter out content that has expired
                self.content_cache[category] = [content for content in cached_content if
                                                current_time < content['generation_time'] + content['content_validity']]
                '''for content in cached_content:
                    # if current_time >= content['generation_time'] + content['content_validity']:
                    print(
                        f"Expired Content - Generation Time: {content['generation_time']}, Current Time: {current_time}",
                        end=' ')
                    '''

    def sigmoid(self, x):
        return 1 / (1 + math.exp(-x))

    def process_content_request(self, communication, content_request, slot, grid_size, ground_station, flag):
        element_type = content_request['type']
        content_coord = content_request['coord']
        hop_count = content_request['hop_count']
        requested_entity_type = content_request['type']
        requested_coord = content_request['coord']
        requested_category = content_request['category']
        requested_content_no = content_request['no']
        self.request_receive += 1
        self.global_request_receive_count += 1
        # Update the request tracking data structure
        if requested_entity_type not in self.record:
            self.record[requested_entity_type] = {}
        if requested_coord not in self.record[requested_entity_type]:
            self.record[requested_entity_type][requested_coord] = {}
        if requested_category not in self.record[requested_entity_type][requested_coord]:
            self.record[requested_entity_type][requested_coord][requested_category] = {}
        if requested_content_no not in self.record[requested_entity_type][requested_coord][requested_category]:
            self.record[requested_entity_type][requested_coord][requested_category][requested_content_no] = {
                'weighted_request_tracking': 0,
                'request_tracking': 0,
                'content_hit': 0,
                'q_value': 0,
                'avg_reward': 0,
                'no_f_time_cached': 0,
                'slot': 0
            }
        self.record[requested_entity_type][requested_coord][requested_category][requested_content_no][
            'request_tracking'] += 1

        if requested_entity_type == "satellite" or requested_entity_type == "UAV":
            self.request_receive_cache += 1
            content = self.find_cache(communication, content_request, slot)
            if content:
                if communication.content_received_time > (content_request['hop_count'] * random.uniform(0, 0.001)) + (
                        (content['size'] * 8) / self.transmission_rate):
                    communication.content_received_time > (content_request['hop_count'] * random.uniform(0, 0.001)) + (
                                (content['size'] * 8) / self.transmission_rate)
                if flag == 0:
                    communication.content_hit += 1
                return True
            else:
                # calculate the receive time here !
                if requested_entity_type == 'satellite':
                    content = ground_station.find_content_in_gs(content_request)
                    if content:
                        self.update_action_space(content, slot, federated_update=False)
                        if communication.content_received_time > (
                                content['size'] * 8) / self.transmission_rate + 2 * random.uniform(0.007,
                                                                                                   0.01) + 2 * random.uniform(
                                0.04, 0.06):
                            communication.content_received_time = (
                                                                          content[
                                                                              'size'] * 8) / self.transmission_rate + 2 * random.uniform(
                                0.007,
                                0.01) + 2 * random.uniform(0.04, 0.06) + 2 * random.uniform(4, 6)
                        if flag == 0:
                            self.content_hit_from_gs += 1
                            communication.content_hit += 1
                        return True
            return False

        if requested_entity_type == "grid":
            (x, y) = communication.get_coordinates_from_index(content_coord, grid_size)
            if self.check_within_range((x, y)):  # if the requested content cord comes under the range of BS
                content=self.generate_content(communication, content_request)
                if content:
                    if communication.content_received_time > (content_request['hop_count'] * random.uniform(0, 0.001)) + (
                        content_request['hop_count'] * ((content['size'] * 8) / self.transmission_rate)):
                        communication.content_received_time = (content_request['hop_count'] * random.uniform(0, 0.001)) + (
                                content_request['hop_count'] * ((content['size'] * 8) / self.transmission_rate))
                return True
            else:
                self.request_receive_cache += 1
                if self.find_cache(content_request):
                    if communication.content_received_time > (
                            content_request['hop_count'] * random.uniform(0, 0.001)) + (
                            content_request['hop_count'] * ((content['size'] * 8) / self.transmission_rate)):
                        communication.content_received_time = (content_request['hop_count'] * random.uniform(0,
                                                                                                             0.001)) + (
                                                                          content_request['hop_count'] * ((content[
                                                                                                               'size'] * 8) / self.transmission_rate))
                    if flag == 0:
                        communication.content_hit += 1

                    return True
                else:
                    return False

    def generate_content(self, communication, content_request):
        content_validity = 10 * 60  # 10 minutes in seconds

        # Get the content category and size based on the request
        content_category = content_request['category']
        content_size = self.content_size.get(content_category, 0)  # Default to 0 if category is not found
        request_recieve_time = content_request['g_time'] + (content_request['hop_count'] * 0.001)
        content_request['time_spent'] = request_recieve_time

        content = {
            'unique_id': content_request['unique_id'],
            'destination': content_request['requesting_vehicle'],
            'generation_time': request_recieve_time,
            'hop_count': 0,
            'content_type': 'grid',  # You can specify the content type here
            'content_category': content_category,
            'content_cord': content_request['coord'],
            'content_no': content_request['no'],
            'content_validity': content_validity,
            'content_receive_time': 0,
            'size': content_size  # Include the content size based on category
        }

        self.content_hit_from_source += 1
        if communication.content_received_time > request_recieve_time + (
                content['size'] * 8) / self.transmission_rate:  # Store the current time
            communication.content_received_time = request_recieve_time + (content['size'] * 8) / self.transmission_rate
        return

    '''def update_action_space(self, content, slot, federated_update):  ##ucb MAB
        # Initialize the Q-value for the content to 0
        # Add content and its associated Q-value
        if content['content_type'] not in self.record:
            self.record[content['content_type']] = {}
        if content['content_coord'] not in self.record[content['content_type']]:
            self.record[content['content_type']][content['content_coord']] = {}
        if content['content_category'] not in self.record[content['content_type']][content['content_coord']]:
            self.record[content['content_type']][content['content_coord']][content['content_category']] = {}
        if content['content_no'] not in self.record[content['content_type']][content['content_coord']][
            content['content_category']]:
            self.record[content['content_type']][content['content_coord']][content['content_category']][
                content['content_no']] = {
                'weighted_request_tracking': 0,
                'request_tracking': 0,
                'content_hit': 0,
                'q_value': 0,
                'avg_reward': 0,
                'no_f_time_cached': 0,
                'slot': 0
            }

        time_spent = (slot * 60) - content['generation_time']
        if self.request_receive_cache > 0:
            self.record[content['content_type']][content['content_coord']][content['content_category']][
                content['content_no']] \
                ['weighted_request_tracking'] \
                = self.sigmoid((0.25 *
                                self.record[content['content_type']][content['content_coord']][
                                    content['content_category']][
                                    content['content_no']] \
                                    ['weighted_request_tracking']) + 0.75 * (
                                       self.record[content['content_type']][content['content_coord']][
                                           content['content_category']][content['content_no']][
                                           'request_tracking'] / self.request_receive_cache))

        p = self.record[content['content_type']][content['content_coord']][content['content_category']][
            content['content_no']] \
            ['weighted_request_tracking']
        s = max(1, self.record[content['content_type']][content['content_coord']]
        [content['content_category']][content['content_no']]['slot'])  # Ensure s >= 1

        no_f_time_cached = max(1, self.record[content['content_type']][content['content_coord']]
        [content['content_category']][content['content_no']]['no_f_time_cached'])  # Ensure >=1

        ucb = np.sqrt((2 * np.log(s)) / no_f_time_cached)  # Now always valid

        local_q_value = self.sigmoid(self.record[content['content_type']][content['content_coord']]
                                     [content['content_category']][content['content_no']]['avg_reward'] +
                                     (self.cache_size / content['size']) +
                                     ((content['content_validity'] - time_spent) / content['content_validity']) +
                                     self.record[content['content_type']][content['content_coord']]
                                     [content['content_category']][content['content_no']][
                                         'weighted_request_tracking'])
        if federated_update:
            federated_q_value = self.aggregator.get_federated_q_value(content)
            q = 0.5 * local_q_value + 0.5 * federated_q_value + ucb  # Weighted Combination
        else:
            q = local_q_value + ucb

        self.record[content['content_type']][content['content_coord']][content['content_category']][
            content['content_no']]['q_value'] = q

        # Add content and associated Q-value to the action space
        self.action_space.append({'content': content, 'q_value': q, 'slot': s, 'popularity': p})
        return'''

    def update_action_space(self, content, slot, federated_update): ##MAB and all
    # Initialize the Q-value for the content to 0
    # Add content and its associated Q-value
            if content['content_type'] not in self.record:
                self.record[content['content_type']]={}
            if content['content_coord'] not in self.record[content['content_type']]:
                self.record[content['content_type']][content['content_coord']]={}
            if content['content_category'] not in self.record[content['content_type']][content['content_coord']]:
                self.record[content['content_type']][content['content_coord']][content['content_category']]={}
            if content['content_no'] not in self.record[content['content_type']][content['content_coord']][content['content_category']]:
                self.record[content['content_type']][content['content_coord']][content['content_category']][content['content_no']]= {
                                'weighted_request_tracking': 0,
                                'request_tracking': 0,
                                'content_hit': 0,
                                'q_value': 0,
                                'avg_reward': 0,
                                'no_f_time_cached':0,
                                'slot': 0
                            }

            time_spent = (slot * 60) - content['generation_time']
            if self.request_receive_cache > 0:
                self.record[content['content_type']][content['content_coord']][content['content_category']][
                    content['content_no']] \
                    ['weighted_request_tracking'] \
                    = self.sigmoid((0.25 *
                                    self.record[content['content_type']][content['content_coord']][
                                        content['content_category']][content['content_no']] \
                                        ['weighted_request_tracking']) + 0.75 * (
                                           self.record[content['content_type']][content['content_coord']][
                                               content['content_category']][content['content_no']][
                                               'request_tracking'] / self.request_receive))

            p = self.record[content['content_type']][content['content_coord']][content['content_category']][
                content['content_no']] \
                ['weighted_request_tracking']
            s = self.record[content['content_type']][content['content_coord']][content['content_category']][
                content['content_no']]['slot']

            q = self.sigmoid(self.record[content['content_type']][content['content_coord']][
                                 content['content_category']] \
                                 [content['content_no']]['avg_reward'])

            self.record[content['content_type']][content['content_coord']][content['content_category']][
                content['content_no']]['q_value'] = q

            # Add content and associated Q-value to the action space
            self.action_space.append({'content': content, 'q_value': q, 'slot': s, 'popularity': p})
            return 

    def append_action_space(self, slot, federated_update):
        # Add content from content_cache to the action space
        for coord, coord_data in self.content_cache.items():
            for category, category_data in coord_data.items():
                for content in category_data:
                    # Initialize the Q-value for the content to 0
                    if content['content_type'] not in self.record:
                        self.record[content['content_type']] = {}
                    if content['content_coord'] not in self.record[content['content_type']]:
                        self.record[content['content_type']][content['content_coord']] = {}
                    if content['content_category'] not in self.record[content['content_type']][
                        content['content_coord']]:
                        self.record[content['content_type']][content['content_coord']][
                            content['content_category']] = {}
                    if content['content_no'] not in self.record[content['content_type']][content['content_coord']][ \
                            content['content_category']]:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][ \
                            content['content_no']] = {
                            'weighted_request_tracking': 0,
                            'request_tracking': 0,
                            'content_hit': 0,
                            'q_value': 0,
                            'avg_reward': 0,
                            'no_f_time_cached': 0,
                            'slot': 0
                        }
                    time_spent = (slot * 60) - content['generation_time']
                    if self.request_receive_cache > 0:
                        self.record[content['content_type']][content['content_coord']][content['content_category']][
                            content['content_no']] \
                            ['weighted_request_tracking'] \
                            = self.sigmoid((0.25 *
                                            self.record[content['content_type']][content['content_coord']][
                                                content['content_category']][
                                                content['content_no']] \
                                                ['weighted_request_tracking']) + 0.75 * (
                                                   self.record[content['content_type']][content['content_coord']][
                                                       content['content_category']][content['content_no']][
                                                       'request_tracking'] / self.request_receive_cache))

                    p = self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']] \
                        ['weighted_request_tracking']
                    s = max(1, self.record[content['content_type']][content['content_coord']]
                    [content['content_category']][content['content_no']]['slot'])  # Ensure s >= 1

                    no_f_time_cached = max(1, self.record[content['content_type']][content['content_coord']]
                    [content['content_category']][content['content_no']]['no_f_time_cached'])  # Ensure >=1

                    ucb = np.sqrt((2 * np.log(s)) / no_f_time_cached)  # Now always valid

                    local_q_value = self.sigmoid(self.record[content['content_type']][content['content_coord']]
                                                 [content['content_category']][content['content_no']]['avg_reward'] +
                                                 (self.cache_size / content['size']) +
                                                 ((content['content_validity'] - time_spent) / content[
                                                     'content_validity']) +
                                                 self.record[content['content_type']][content['content_coord']]
                                                 [content['content_category']][content['content_no']][
                                                     'weighted_request_tracking'])
                    if federated_update:
                        federated_q_value = self.aggregator.get_federated_q_value(content)
                        q = 0.5 * local_q_value + 0.5 * federated_q_value + ucb  # Weighted Combination
                    else:
                        q = local_q_value + ucb

                    self.record[content['content_type']][content['content_coord']][content['content_category']][
                        content['content_no']]['q_value'] = q

                    # Add content and associated Q-value to the action space
                    self.action_space.append({'content': content, 'q_value': q, 'slot': s, 'popularity': p})

    '''def select_action(self):  # MAB implementation
        # Clear the existing content cache
        self.clear_cache()

        remaining_cache_size = self.cache_size
        selected_actions = []

        average_q_value = sum(action['q_value'] for action in self.action_space) / (2 * len(self.action_space))

        if random.random() < self.epsilon:
            # Exploration: Randomly choose content with q_value > average
            eligible_actions = [action for action in self.action_space if action['q_value'] > average_q_value]
            random.shuffle(eligible_actions)

            for action in eligible_actions:
                selected_content = action['content']
                content_size = selected_content['size']

                if remaining_cache_size - content_size >= 0.01:
                    s_type = selected_content['content_type']
                    s_coord = selected_content['content_coord']
                    s_category = selected_content['content_category']
                    s_no = selected_content['content_no']

                    if s_coord not in self.content_cache:
                        self.content_cache[s_coord] = {}

                    if s_category not in self.content_cache[s_coord]:
                        self.content_cache[s_coord][s_category] = []

                    if selected_content not in self.content_cache[s_coord][s_category]:
                        self.content_cache[s_coord][s_category].append(selected_content)
                        self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                    # Update the remaining cache size
                    remaining_cache_size -= content_size
                else:
                    # print("Cache size limit reached. Cannot add more content.")
                    break
        else:
            # Exploitation: Sort eligible actions based on q value
            eligible_actions = [action for action in self.action_space if action['q_value'] > average_q_value]
            eligible_actions.sort(key=lambda x: x['q_value'], reverse=True)

            for action in eligible_actions:
                selected_content = action['content']
                content_size = selected_content['size']

                if remaining_cache_size - content_size >= 0.01:
                    s_type = selected_content['content_type']
                    s_coord = selected_content['content_coord']
                    s_category = selected_content['content_category']
                    s_no = selected_content['content_no']

                    if s_coord not in self.content_cache:
                        self.content_cache[s_coord] = {}

                    if s_category not in self.content_cache[s_coord]:
                        self.content_cache[s_coord][s_category] = []

                    if selected_content not in self.content_cache[s_coord][s_category]:
                        self.content_cache[s_coord][s_category].append(selected_content)
                        self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                    # Update the remaining cache size
                    remaining_cache_size -= content_size
                else:
                    # print("Cache size limit reached. Cannot add more content.")
                    break

        return'''

    '''def select_action(self):  #LRU
        # Clear the existing content cache
        remaining_cache_size = self.cache_size
        selected_actions = []

        # Sort actions based on 's' values in descending order
        sorted_actions = sorted(self.action_space, key=lambda action: action['slot'], reverse=True)

        for action in sorted_actions:
            selected_content = action['content']
            content_size = selected_content['size']

            s_type = selected_content['content_type']
            s_coord = selected_content['content_coord']
            s_category = selected_content['content_category']
            s_no = selected_content['content_no']

            if s_coord not in self.content_cache:
                self.content_cache[s_coord] = {}

            if s_category not in self.content_cache[s_coord]:
                self.content_cache[s_coord][s_category] = []

            if selected_content not in self.content_cache[s_coord][s_category]:
                self.content_cache[s_coord][s_category].append(selected_content)
                self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                # Update the remaining cache size
                remaining_cache_size -= content_size

                # Check if cache size is overwhelmed
                if remaining_cache_size < 0.01:
                    break

        # If cache size is still not overwhelmed and there are items with 's' value 0, choose randomly
        if remaining_cache_size > 0.01:
            zero_s_value_actions = [action for action in sorted_actions if action['slot'] == 0]
            if(zero_s_value_actions):
                random_action = random.choice(zero_s_value_actions)
            else:
                return

            for action in zero_s_value_actions:
                selected_content = random_action['content']
                content_size = selected_content['size']

                s_type = selected_content['content_type']
                s_coord = selected_content['content_coord']
                s_category = selected_content['content_category']
                s_no = selected_content['content_no']

                if s_coord not in self.content_cache:
                    self.content_cache[s_coord] = {}

                if s_category not in self.content_cache[s_coord]:
                    self.content_cache[s_coord][s_category] = []

                if selected_content not in self.content_cache[s_coord][s_category]:
                    self.content_cache[s_coord][s_category].append(selected_content)
                    self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                    # Update the remaining cache size
                    remaining_cache_size -= content_size

                    # Check if cache size is overwhelmed
                    if remaining_cache_size < 0.01:
                        break

        return'''

    def select_action(self):  #Popularity
            # Clear the existing content cache
            self.clear_cache()
            remaining_cache_size = self.cache_size
            selected_actions = []

            # Sort actions based on 'popularity' values in descending order
            sorted_actions = sorted(self.action_space, key=lambda action: action['popularity'], reverse=True)

            for action in sorted_actions:
                selected_content = action['content']
                content_size = selected_content['size']

                s_type = selected_content['content_type']
                s_coord = selected_content['content_coord']
                s_category = selected_content['content_category']
                s_no = selected_content['content_no']

                if s_coord not in self.content_cache:
                    self.content_cache[s_coord] = {}

                if s_category not in self.content_cache[s_coord]:
                    self.content_cache[s_coord][s_category] = []

                if selected_content not in self.content_cache[s_coord][s_category]:
                    self.content_cache[s_coord][s_category].append(selected_content)
                    self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                    # Update the remaining cache size
                    remaining_cache_size -= content_size

                    # Check if cache size is overwhelmed
                    if remaining_cache_size < 0.01:
                        break

            # If cache size is still not overwhelmed and there are items with 's' value 0, choose randomly
            if remaining_cache_size > 0.01:
                zero_s_value_actions = [action for action in sorted_actions if action['slot'] == 0]
                if (zero_s_value_actions):
                    random_action = random.choice(zero_s_value_actions)
                else:
                    return

                for action in zero_s_value_actions:
                    selected_content = random_action['content']
                    content_size = selected_content['size']

                    s_type = selected_content['content_type']
                    s_coord = selected_content['content_coord']
                    s_category = selected_content['content_category']
                    s_no = selected_content['content_no']

                    if s_coord not in self.content_cache:
                        self.content_cache[s_coord] = {}

                    if s_category not in self.content_cache[s_coord]:
                        self.content_cache[s_coord][s_category] = []

                    if selected_content not in self.content_cache[s_coord][s_category]:
                        self.content_cache[s_coord][s_category].append(selected_content)
                        self.record[s_type][s_coord][s_category][s_no]['no_f_time_cached'] += 1

                        # Update the remaining cache size
                        remaining_cache_size -= content_size

                        # Check if cache size is overwhelmed
                        if remaining_cache_size < 0.01:
                            break

            return

    def get_reward(self):
        # Define the reward function based on the selected action and content popularity
        for entity_type, coord_dict in self.record.items():
            for coord, category_dict in coord_dict.items():
                for category, content_no_dict in category_dict.items():
                    for content_no, content_info in content_no_dict.items():
                        if self.is_content_in_cache(coord, category, content_no):
                            avg_reward_value = content_info.get('avg_reward', 0)
                            q = content_info.get('q_value', 0)
                            c = content_info.get('no_f_time_cached', 0)
                            h = content_info.get('content_hit', 0)
                            if h > 0 and c > 0:
                                avg_reward_value = avg_reward_value - (avg_reward_value - (h * q)) / c
                                self.record[entity_type][coord][category][content_no]['avg_reward'] = avg_reward_value
                        self.record[entity_type][coord][category][content_no]['q_value'] = 0
                        self.content_cache_hit += self.record[entity_type][coord][category][content_no]['content_hit']
                        self.record[entity_type][coord][category][content_no]['content_hit'] = 0
        # print(f"reward: {self.content_hit}")
        return

    def is_content_in_cache(self, coord, category, content_no):
        # Add your logic to check if content is in content_cache
        # For example, assuming content_cache is a dictionary of the form:
        # {entity_type: {coord: {category: [content1, content2, ...]}}}
        return (
                coord in self.content_cache
                and category in self.content_cache[coord]
                and any(content['content_no'] == content_no for content in self.content_cache[coord][category])
        )

    def check_within_range(self, cord):

        x1, y1 = self.current_location
        x2, y2 = cord
        x_within_range = abs(x1 - x2) <= 150
        y_within_range = abs(y1 - y2) <= 150

        if x_within_range and y_within_range:
            return True
        else:
            return False
            # self.generate_content(communications, content_request)

    def find_cache(self, communication, content_request, slot):
        # print('hi b--')
        requested_entity_type = content_request['type']
        requested_entity_no = content_request['coord']
        requested_category = content_request['category']
        requested_content_no = content_request['no']

        # Check if the requested content is in the content cache for the specified category
        if requested_entity_no in self.content_cache:
            if requested_category in self.content_cache[requested_entity_no]:
                category_cache = self.content_cache[requested_entity_no][requested_category]
                for content in category_cache:
                    if content['content_no'] == content_request['no']:
                        self.track_content_hit(content, slot)
                        return content
        return None

    def track_content_hit(self, content, slot):
        # print('track_content_hit')
        content_type = content['content_type']
        content_coord = content['content_coord']
        content_category = content['content_category']
        content_no = content['content_no']

        if content_type not in self.record:
            self.record[content_type] = {}

        if content_coord not in self.record[content_type]:
            self.record[content_type][content_coord] = {}

        if content_category not in self.record[content_type][content_coord]:
            self.record[content_type][content_coord][content_category] = {}

        if content_no not in self.record[content_type][content_coord][content_category]:
            self.record[content_type][content_coord][content_category][content_no] = {
                'weighted_request_tracking': 0,
                'request_tracking': 0,
                'content_hit': 0,
                'q_value': 0,
                'avg_reward': 0,
                'no_f_time_cached': 0,
                'slot': 0
            }

        # Update the content hit information
        self.record[content_type][content_coord][content_category][content_no]['content_hit'] += 1
        self.record[content_type][content_coord][content_category][content_no]['slot'] = slot
        # print(f"track_content_hit: {self.record[content_type][content_coord][content_category][content_no]['content_hit']}")
        return

    def send_update_to_federated_server(self):
        """
        Sends the vehicleâ€™s Q-values to the federated server.
        """
        self.aggregator.receive_local_update(self.bs_id, self.record)

    def clear_cache(self):
        # Clear the existing content cache
        self.content_cache = {}

    def run(self, current_time, slot):
        self.cache_cleanup(current_time)
        if ((slot - 1) % 10 == 0):
            if slot > 20:
                self.get_reward()
            if slot > 10:
                self.append_action_space(slot, federated_update=False)
                if len(self.action_space):
                    self.select_action()
                self.action_space = []
                self.send_update_to_federated_server()

